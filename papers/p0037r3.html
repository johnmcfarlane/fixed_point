<p><strong>Document number</strong>: LEWG, SG14, SG6: P0037R3<br />
<strong>Date</strong>: 2016-10-17<br />
<strong>Reply-to</strong>: John McFarlane, <a href="mailto:mcfarlane.john+fixed-point@gmail.com">mcfarlane.john+fixed-point@gmail.com</a><br />
<strong>Reply-to</strong>: Michael Wong, <a href="mailto:fraggamuffin@gmail.com">fraggamuffin@gmail.com</a><br />
<strong>Audience</strong>: SG6, SG14, LEWG</p>
<h1 id="fixed-point-real-numbers">Fixed-Point Real Numbers</h1>
<h2 id="i.-introduction">I. Introduction</h2>
<p>This proposal introduces a system for performing binary fixed-point arithmetic using integral types.</p>
<h2 id="ii.-motivation">II. Motivation</h2>
<p>Floating-point types are an exceedingly versatile and widely supported method of expressing real numbers on modern architectures.</p>
<p>However, there are certain situations where fixed-point arithmetic is preferable:</p>
<ul>
<li>Some systems lack native floating-point registers and must emulate them in software;</li>
<li>many others are capable of performing some or all operations more efficiently using integer arithmetic;</li>
<li>certain applications can suffer from the variability in precision which comes from a dynamic radix point <a href="http://www.pathengine.com/Contents/Overview/FundamentalConcepts/WhyIntegerCoordinates/page.php">[1]</a>;</li>
<li>in situations where a variable exponent is not desired, it takes valuable space away from the significand and reduces precision and</li>
<li>not all hardware and compilers produce exactly the same results, leading to non-deterministic results.</li>
</ul>
<p>Integer types provide the basis for an efficient representation of binary fixed-point real numbers. However, laborious, error-prone steps are required to normalize the results of certain operations and to convert to and from fixed-point types.</p>
<p>A set of tools for defining and manipulating fixed-point types is proposed. These tools are designed to make work easier for those who traditionally use integers to perform low-level, high-performance fixed-point computation. They are composable such that a wide range of trade-offs between speed, accuracy and safety are supported.</p>
<h2 id="iii.-impact-on-the-standard">III. Impact On the Standard</h2>
<p>This proposal is a pure library extension. It does not require changes to any standard classes or functions. It adds several new class and function templates to new header file, <code>&lt;fixed_point&gt;</code>.</p>
<p>It depends on two new class templates, <code>width&lt;class&gt;</code> and <code>set_width&lt;class, int&gt;</code>, added to existing header file, <code>&lt;cstdint&gt;</code> and proposed in P0381 <a href="http://johnmcfarlane.github.io/fixed_point/papers/p0381r1.html">[10]</a>.</p>
<h2 id="iv.-design-decisions">IV. Design Decisions</h2>
<p>The design is driven by the following aims in roughly descending order:</p>
<ol style="list-style-type: decimal">
<li>to automate the task of using integer types to perform low-level binary fixed-point arithmetic;</li>
<li>to facilitate a style of code that is intuitive to anyone who is comfortable with integer and floating-point arithmetic;</li>
<li>to treat fixed-point as a super-set of integer such that a fixed-point type with an exponent of zero can provide a drop-in replacement for its underlying integer type</li>
<li>to avoid incurring expense for unused features - including compilation time.</li>
</ol>
<p>More generally, the aim of this proposal is to contain within a single API all the tools necessary to perform binary fixed-point arithmetic. The design facilitates a wide range of competing compile-time strategies for avoiding overflow and precision loss, but implements only the simplest by default. Similarly, orthogonal concerns such as run-time overflow detection and rounding modes are deferred to the underlying integer types used as storage.</p>
<h3 id="class-template">Class Template</h3>
<p>Fixed-point numbers are specializations of</p>
<pre><code>template &lt;class Rep, int Exponent&gt;
class fixed_point;</code></pre>
<p>where the template parameters are described as follows.</p>
<h4 id="rep-type-template-parameter"><code>Rep</code> Type Template Parameter</h4>
<p>This parameter identifies the capacity and signedness of the underlying type used to represent the value. In other words, the size of the resulting type will be <code>sizeof(Rep)</code> and it will be signed iff <code>std::numeric_limits&lt;Rep&gt;::is_signed</code> is true.</p>
<p><code>Rep</code> may be a fundamental integral type or similar integer-like type. The most suitable types are: <code>std::int8_t</code>, <code>std::uint8_t</code>, <code>std::int16_t</code>, <code>std::uint16_t</code>, <code>std::int32_t</code> and <code>std::uint32_t</code>. In limited situations, <code>std::int64_t</code> and <code>std::uint64_t</code> can be used. The reasons for these limitations relate to the difficulty in finding a type that is suitable for performing lossless integer division.</p>
<p>The characteristics of <code>Rep</code> are passed to the fixed-point type. If, for example, <code>Rep</code> has an alternative rounding style, overflow handling strategy or large storage capacity, then the <code>fixed_point</code> specialization will benefit from this feature. By defaulting to <code>int</code> for its representation, <code>fixed_point</code> defaults to machine-level efficiency and minimal compile-time overhead.</p>
<h4 id="exponent-non-type-template-parameter"><code>Exponent</code> Non-Type Template Parameter</h4>
<p>The exponent of a fixed-point type is the equivalent of the exponent field in a floating-point type and shifts the stored value by the requisite number of bits necessary to produce the desired range. The default value of <code>Exponent</code> is zero, giving <code>fixed_point&lt;T&gt;</code> the same range as <code>T</code>. By far the most common use of fixed-point is to store values with fractional digits. Thus, the exponent is typically a negative value.</p>
<p>The resolution of a specialization of <code>fixed_point</code> is</p>
<pre><code>pow(2, Exponent)</code></pre>
<p>and the minimum and maximum values are</p>
<pre><code>std::numeric_limits&lt;Rep&gt;::min() * pow(2, Exponent)</code></pre>
<p>and</p>
<pre><code>std::numeric_limits&lt;Rep&gt;::max() * pow(2, Exponent)</code></pre>
<p>respectively.</p>
<p>Any usage that results in values of <code>Exponent</code> which lie outside the range, (<code>INT_MIN / 2</code>, <code>INT_MAX / 2</code>), may result in undefined behavior and/or overflow or underflow. This range of exponent values is far in excess of the largest built-in floating-point type and should be adequate for all intents and purposes.</p>
<h3 id="make_fixed-and-make_ufixed-helper-types"><code>make_fixed</code> and <code>make_ufixed</code> Helper Types</h3>
<p>The <code>Exponent</code> template parameter is versatile and concise. It is an intuitive scale to use when considering the full range of positive and negative exponents a fixed-point type might possess. It also corresponds to the exponent field of built-in floating-point types.</p>
<p>However, most fixed-point formats can be described more intuitively by the cardinal number of integer and/or fractional digits they contain. Most users will prefer to distinguish fixed-point types using these parameters.</p>
<p>For this reason, two aliases are defined in the style of <code>make_signed</code>.</p>
<p>These aliases are declared as:</p>
<pre><code>template &lt;int IntegerDigits, int FractionalDigits = 0, class Archetype = signed&gt;
using make_fixed;</code></pre>
<p>and</p>
<pre><code>template &lt;int IntegerDigits, int FractionalDigits = 0, class Archetype = unsigned&gt;
using make_ufixed;</code></pre>
<p>They resolve to a <code>fixed_point</code> specialization with the given signedness and number of integer and fractional digits. They may contain additional integer digits.</p>
<p>For example, one could define and initialize an 8-bit, unsigned, fixed-point variable with four integer digits and four fractional digits:</p>
<pre><code>make_ufixed&lt;4, 4&gt; value { 15.9375 };</code></pre>
<p>or a 32-bit, signed, fixed-point number with two integer digits and 29 fractional digits:</p>
<pre><code>make_fixed&lt;2, 29&gt; value { 3.141592653 };</code></pre>
<p>Type parameter, <code>Archetype</code>, is provided in the case that a <code>fixed_point</code> specialization is desired which has as the <code>Rep</code> parameter some type other than a built-in integral. The signedness of <code>Archetype</code> corresponds to the signedness of the resultant <code>fixed_point</code> specialization although the size does not.</p>
<h3 id="conversion">Conversion</h3>
<p>Fixed-point numbers can be converted to and from other arithmetic types. A precondition is that the conversion is supported by the <code>Rep</code> type. Implicit conversion is allowed in cases where the destination type can store all values of the source type.</p>
<p>For example, this implicit initialization is valid because all values of <code>uint8_t</code> can be stored in <code>a</code></p>
<pre class="c++11"><code>fixed_point&lt;uint16_t, -8&gt; a = uint8_t{};</code></pre>
<p>but none of these implicit initializations compile:</p>
<pre class="c++11"><code>fixed_point&lt;uint16_t, -8&gt; b = uint16_t{};  // maximum value exceeded
fixed_point&lt;uint16_t, -8&gt; c = int8_t{};  // minimum value exceeded
fixed_point&lt;uint16_t, -8&gt; d = fixed_point&lt;uint16_t, -16&gt;{};  // precision loss
uint16_t e = fixed_point&lt;uint16_t, -8&gt;{};  // precision loss
fixed_point&lt;uint16_t, -8&gt; f = double{};  // all of the above</code></pre>
<p>While effort is made to ensure that significant digits are not lost during conversion, no effort is made to avoid rounding errors. Whatever would happen when converting to and from <code>Rep</code> largely applies to <code>fixed_point</code> objects also. For example:</p>
<pre class="c++11"><code>fixed_point&lt;int, -1&gt;{.499}==0.0</code></pre>
<p>...equates to <code>true</code> and is considered an acceptable rounding error.</p>
<h3 id="operator-overloads">Operator Overloads</h3>
<p>Any operators that might be applied to integer types can also be applied to fixed-point types. A guiding principle of operator overloads is that they perform as little run-time computation as is practically possible.</p>
<p>With the exception of shift and comparison operators, binary operators can take any combination of:</p>
<ul>
<li>one or two fixed-point arguments and</li>
<li>zero or one arguments of any arithmetic type, i.e. a type for which <code>numeric_limits</code> is specialized.</li>
</ul>
<p>Where the inputs are not identical fixed-point types, a simple set of promotion-like rules are applied to determine the return type:</p>
<ol style="list-style-type: decimal">
<li>If one of the arguments is a floating-point type, then the type of the result is the smallest floating-point type of equal or greater size than the inputs.</li>
<li>If one of the arguments is an integral type, then it is converted to a <code>fixed_point&lt;&gt;</code> type with <code>Exponent</code> zero such that rule 3) applies ...</li>
<li>If both arguments are fixed-point then:
<ol style="list-style-type: decimal">
<li>If the operation is addition or subtraction then the operand with the greater exponent is converted to a type with the same exponent as the other operand and then 3) is applied.</li>
<li>If the operation is division then the left-hand operand is widened and padded with as many low-order bits as the right-hand operand has integer bits and then 3) is applied.<br />
</li>
<li>Then for all operations, the arithmetic operation is performed on the underlying integers and returned as a fixed-point type with the correct Exponent and without any extra shift operations being performed on the result.</li>
</ol></li>
</ol>
<p>Some examples:</p>
<pre class="c++11"><code>fixed_point&lt;uint8_t, -3&gt;{8} + fixed_point&lt;int8_t, -4&gt;{3} === fixed_point&lt;int, -4&gt;{11}
fixed_point&lt;uint8_t, -3&gt;{8} + 3 === fixed_point&lt;int, -3&gt;{11}
fixed_point&lt;uint8_t, -3&gt;{8} + float{3} === float{11}</code></pre>
<p>The reasoning behind this choice is a combination of predictability and performance. It is explained for each rule as follows:</p>
<ol style="list-style-type: decimal">
<li>ensures that the least computation is performed where fixed-point types are used exclusively. Aside from division requiring shift operations, should require similar computational costs to equivalent integer operations;</li>
<li>loosely follows the promotion rules for mixed-mode arithmetic, ensures values with exponents far beyond the range of the fixed-point type are catered for and avoids costly conversion from floating-point to integer.</li>
</ol>
<p>A guiding aim is for specializations with <code>Exponent</code> set to 0 to behave as closely as possible like their <code>Rep</code>. For instance, where possible, an object of type, <code>int</code>, should be interchangeable with <code>fixed_point&lt;&gt;</code>.</p>
<p>Shift operator overloads require an integer type as the right-hand parameter.</p>
<p>Comparison operators convert the inputs to a common result type following rules similar to addition and subtraction above before performing a comparison and returning <code>true</code> or <code>false</code>.</p>
<h4 id="overflow">Overflow</h4>
<p>Because arithmetic operators return a result of equal capacity to their inputs, they carry a risk of overflow. For instance,</p>
<pre><code>make_ufixed&lt;2, 30&gt;(3) + make_ufixed&lt;2, 30&gt;(1)</code></pre>
<p>is zero on architectures where <code>int</code> is 4 bytes because a type with 2 integer bits cannot store a value of 4.</p>
<p>The result of overflow of any bits in a fixed-point value depends entirely on how <code>Rep</code> handles overflow. Thus, for built-in signed types, the result is undefined and for built-in unsigned types, the value wraps around.</p>
<h4 id="underflow">Underflow</h4>
<p>The other typical cause of lost bits is underflow where, for example,</p>
<pre><code>15 / 2</code></pre>
<p>results in a value of 7.</p>
<p>Unlike the other arithmetic operators which aim to get as close to machine perfomance as possible, the division operator widens and pads its operands such that:</p>
<pre><code>make_fixed&lt;7, 0&gt;(15) / make_fixed&lt;7, 0&gt;(2)</code></pre>
<p>results in a type of <code>fixed_point&lt;int, -7&gt;</code> and a value of 7.5. However, division can still result in loss of precision due to the limitations of representing rational numbers using digital systems.</p>
<h3 id="dealing-with-overflow-and-flushes">Dealing With Overflow and Flushes</h3>
<p>Errors resulting from overflow and flushes are two of the biggest headaches related to fixed-point arithmetic. Integers suffer the same kinds of errors but are somewhat easier to reason about as they lack fractional digits. Floating-point numbers are largely shielded from these errors by their variable exponent and implicit bit.</p>
<p>Four strategies for avoiding overflow in fixed-point types are presented:</p>
<ol style="list-style-type: decimal">
<li>simply leave it to the user to avoid overflow;</li>
<li>allow the user to provide a custom type for <code>Rep</code> which behaves differently from built-in integral types;</li>
<li>promote the result to a larger type to ensure sufficient capacity or</li>
<li>adjust the exponent of the result upward to ensure that the top limit of the type is sufficient to preserve the most significant digits at the expense of the less significant digits.</li>
</ol>
<p>For most arithmetic operators, a combination of choices 1) and 3) is taken because it most closely follows the behavior of integer types. Thus it should cause the least surprise to the fewest users. This makes it far easier to reason about in code where functions are written with a particular type in mind. It also requires the least computation in most cases.</p>
<p>Choice 2) is beyond the scope of this proposal and is covered in more detail in the section, <strong>Alternative Types for <code>Rep</code></strong>.</p>
<p>Choice 4) is reasonably robust to overflow events. However, it represent different trade-offs and is less portable as it is sensitive to the width of the <code>Rep</code> type.</p>
<h4 id="named-arithmetic-functions">Named Arithmetic Functions</h4>
<p>The following named function templates can be used as alternatives to arithmetic operators, <code>-</code>, <code>+</code>, <code>*</code> and <code>/</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> negate(<span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt;&amp; rhs);

<span class="kw">template</span>&lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> add(<span class="at">const</span> Lhs&amp; lhs, <span class="at">const</span> Rhs&amp; rhs);

<span class="kw">template</span>&lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> subtract(<span class="at">const</span> Lhs&amp; lhs, <span class="at">const</span> Rhs&amp; rhs);

<span class="kw">template</span>&lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> multiply(<span class="at">const</span> Lhs&amp; lhs, <span class="at">const</span> Rhs&amp; rhs);

<span class="kw">template</span>&lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> divide(<span class="at">const</span> Lhs&amp; lhs, <span class="at">const</span> Rhs&amp; rhs);</code></pre></div>
<p>They eschew machine-friendly integer promotion in favor of custom widening rules that place conciseness and correctness before raw performance.</p>
<p>Multiplying two 8-bit values does not necessarily produce an int-sized result:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f = fixed_point&lt;<span class="dt">uint8_t</span>, <span class="dv">-4</span>&gt;{<span class="fl">15.9375</span>};
<span class="kw">auto</span> p = multiply(f, f);
<span class="co">// p === fixed_point&lt;uint16_t, -8&gt;{254.00390625}</span></code></pre></div>
<p>The arithmetic operators shield the user from none of the pitfalls of fixed-point arithmetic. For example, naive use of <code>*</code> can easily lead to surprising results.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f = fixed_point&lt;<span class="dt">unsigned</span>, <span class="dv">-28</span>&gt;{<span class="fl">15.9375</span>};
<span class="kw">auto</span> p = f * f;
<span class="co">// p === fixed_point&lt;unsigned, -56&gt;{0}</span></code></pre></div>
<p>In contrast, the <code>multiply</code> function returns appropriately widened results. It does a better job at avoiding unnecessary narrowing and catastrophic information loss.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f = fixed_point&lt;<span class="dt">unsigned</span>, <span class="dv">-28</span>&gt;{<span class="fl">15.9375</span>};
<span class="kw">auto</span> p = multiply(f, f);
<span class="co">// p === fixed_point&lt;uint64_t, -56&gt;{254.00390625}</span></code></pre></div>
<p>Functions, <code>add</code> and <code>subtract</code> go to similar lengths to preserve results:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a1 = fixed_point&lt;<span class="dt">int8_t</span>, <span class="dv">32</span>&gt;{<span class="bn">0x7f00000000LL</span>};
<span class="kw">auto</span> a2 = fixed_point&lt;<span class="dt">int8_t</span>, <span class="dv">0</span>&gt;{<span class="bn">0x7f</span>};
<span class="kw">auto</span> s = add(a1, a2);
<span class="co">// s === fixed_point&lt;int64_t, 0&gt;{0x7f0000007fLL}</span></code></pre></div>
<p>Function, <code>divide</code>, however serves a different purpose. Operator <code>/</code> behaves very differently than <code>*</code> and does not provide access to machine-efficient integer division. So <code>divide</code> is given that job instead. The reason why the user is protected from integer division quickly becomes apparent:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> n = fixed_point&lt;<span class="dt">uint32_t</span>, <span class="dv">-16</span>&gt;{<span class="dv">1</span>};
<span class="kw">auto</span> d = fixed_point&lt;<span class="dt">uint32_t</span>, <span class="dv">-16</span>&gt;{<span class="dv">2</span>};

<span class="kw">auto</span> q1 = n / d;
<span class="co">// q1 === fixed_point&lt;uint64_t, -32&gt;{0.5}</span>

<span class="kw">auto</span> q2 = divide(n, d);
<span class="co">// q2 === fixed_point&lt;uint32_t, 0&gt;{0}</span></code></pre></div>
<h3 id="alternative-types-for-rep">Alternative Types for <code>Rep</code></h3>
<p>Using built-in integral types as the default underlying representation minimizes certain costs:</p>
<ul>
<li>many fixed-point operations are as efficient as their integral equivalents;</li>
<li>compile-time complexity is kept relatively low and</li>
<li>the behavior of fixed-point types should cause few surprises.</li>
</ul>
<p>However, this choice also brings with it many of the deficiencies of built-in types. For example:</p>
<ul>
<li>the typical rounding behavior is distinct for:
<ul>
<li>conversion from floating-point types;</li>
<li>right shift and</li>
<li>divide operations;</li>
</ul></li>
<li>all of these rounding behaviors cause drift and propagate error;</li>
<li>overflow, underflow and flush are handled silently with wrap-around or undefined behavior;</li>
<li>divide-by-zero similarly results in undefined behavior and</li>
<li>the range of values is limited by the largest type: <code>long long int</code>.</li>
</ul>
<p>The effort involved in addressing these deficiencies is non-trivial and on-going (for example <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0105r0.html">[2]</a>). As solutions are made available, it should become easier to define custom integral types which address concerns surrounding robustness and correctness. Such types deserve their place in the standard library.</p>
<h4 id="example-custom-type-integer">Example Custom Type, <code>integer</code></h4>
<p>A composable system of integer types that is suitable for use with <code>fixed_point</code> might take the following form:</p>
<pre><code>// size may be rounded up in some cases;
template &lt;int NumBytes, bool IsSigned = true&gt;
class sized_integer;

// may take built-in or sized_integer as Rep parameter
template &lt;class Rep = int, rounding Rounding = rounding::towards_odd&gt;
class rounding_integer;

// may take built-in, sized_integer or rounding_integer as Rep parameter
template &lt;class Rep = int, overflow Overflow = overflow::exception&gt;
class overflow_integer;

// a &#39;kitchen sink&#39; custom integer type  
template &lt;int NumBytes, bool IsSigned = true, rounding Rounding = rounding::towards_odd, overflow Overflow = overflow::exception&gt;
using integer = 
  overflow_integer&lt;
    rounding_integer&lt;
      sized_integer&lt;NumBytes, IsSigned&gt;,
      Rounding&gt;,
    Overflow&gt;;</code></pre>
<p>Any of these types might be used to compose <code>fixed_point</code> specializations without paying (in compile-time complexity) for features that are not used.</p>
<p>While the issues related to integer types affect the fixed-point types they support, they are not specific to fixed-point. It would not only be premature - but inappropriate - to attempt to address rounding and error handling at the level of a fixed-point type.</p>
<h4 id="required-specializations">Required Specializations</h4>
<p>For a type to be suitable as parameter, <code>Rep</code>, of <code>fixed_point</code>, it must meet the following requirements:</p>
<ul>
<li>it must have specialized the following existing standard library types:
<ul>
<li><code>numeric_limits</code></li>
<li><code>make_signed</code> and <code>make_unsigned</code></li>
</ul></li>
<li>it must have specialized the following proposed standard library types:
<ul>
<li><code>width</code> and <code>set_width</code> as described in P0381 <a href="http://johnmcfarlane.github.io/fixed_point/papers/p0381r1.html">[10]</a></li>
</ul></li>
</ul>
<p>Note that <code>make_signed</code> and <code>make_unsigned</code> must not be specialized for custom types. Unless this rule can be relaxed, some equivalent mechanism must be introduced in order for custom types to be used with <code>fixed_point&lt;&gt;</code>. One possibility is the addition of <code>numeric_limits&lt;&gt;::signed</code> and <code>numeric_limits&lt;&gt;::unsigned</code> type aliases.</p>
<h3 id="example">Example</h3>
<p>The following function, <code>magnitude</code>, calculates the magnitude of a 3-dimensional vector.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Fp&gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> magnitude(Fp x, Fp y, Fp z)
{
    <span class="cf">return</span> sqrt(x*x+y*y+z*z);
}</code></pre></div>
<p>And here is a call to <code>magnitude</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> m = magnitude(
        fixed_point&lt;<span class="dt">uint16_t</span>, <span class="dv">-12</span>&gt;(<span class="dv">1</span>),
        fixed_point&lt;<span class="dt">uint16_t</span>, <span class="dv">-12</span>&gt;(<span class="dv">4</span>),
        fixed_point&lt;<span class="dt">uint16_t</span>, <span class="dv">-12</span>&gt;(<span class="dv">9</span>));
<span class="co">// m === fixed_point&lt;uint32_t, -24&gt;{9.8994948863983154}</span></code></pre></div>
<h2 id="v.-technical-specification">V. Technical Specification</h2>
<h3 id="header-fixed_point-synopsis">Header &lt;fixed_point&gt; Synopsis</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt; <span class="kw">class</span> fixed_point;

  <span class="kw">template</span> &lt;<span class="dt">int</span> IntegerDigits, <span class="dt">int</span> FractionalDigits = <span class="dv">0</span>, <span class="kw">class</span> Archetype = <span class="dt">signed</span>&gt;
    <span class="kw">using</span> make_fixed;
  <span class="kw">template</span> &lt;<span class="dt">int</span> IntegerDigits, <span class="dt">int</span> FractionalDigits = <span class="dv">0</span>, <span class="kw">class</span> Archetype = <span class="dt">unsigned</span>&gt;
    <span class="kw">using</span> make_ufixed;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>==(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>!=(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt;(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt;(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>&gt;=(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt;=(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> fixed_point&lt;Rep, Exponent&gt; <span class="kw">operator</span>-(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> fixed_point&lt;Rep, Exponent&gt; <span class="kw">operator</span>+(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> fixed_point&lt;Rep, Exponent&gt; <span class="kw">operator</span>-(
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    fixed_point&lt;Rep, Exponent&gt; &amp; <span class="kw">operator</span>+=(
      fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    fixed_point&lt;Rep, Exponent&gt; &amp; <span class="kw">operator</span>-=(
      fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    fixed_point&lt;Rep, Exponent&gt; &amp; <span class="kw">operator</span>*=(
      fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    fixed_point&lt;Rep, Exponent&gt; &amp; <span class="kw">operator</span>/=(
      fixed_point&lt;Rep, Exponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; rhs) <span class="kw">noexcept</span>;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>==(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>!=(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>&gt;(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>&gt;=(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>&lt;=(<span class="at">const</span> Lhs &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>+(
      <span class="at">const</span> Lhs &amp; lhs,
      <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Lhs, <span class="kw">class</span> Rhs&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>-(
      <span class="at">const</span> Lhs &amp; lhs,
      <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>*(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>/(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> Integer&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>*(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> Integer &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> Integer&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>/(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> Integer &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Integer, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>*(
      <span class="at">const</span> Integer &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Integer, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>/(
      <span class="at">const</span> Integer &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> Float&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>*(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> Float &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> LhsExponent, <span class="kw">class</span> Float&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>/(
      <span class="at">const</span> fixed_point&lt;LhsRep, LhsExponent&gt; &amp; lhs,
      <span class="at">const</span> Float &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Float, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>*(
      <span class="at">const</span> Float &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Float, <span class="kw">class</span> RhsRep, <span class="dt">int</span> RhsExponent&gt;
    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span>/(
      <span class="at">const</span> Float &amp; lhs,
      <span class="at">const</span> fixed_point&lt;RhsRep, RhsExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> Exponent, <span class="kw">class</span> Rhs&gt;
    fixed_point&lt;LhsRep, Exponent&gt; &amp; <span class="kw">operator</span>+=(fixed_point&lt;LhsRep, Exponent&gt; &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> Exponent, <span class="kw">class</span> Rhs&gt;
    fixed_point&lt;LhsRep, Exponent&gt; &amp; <span class="kw">operator</span>-=(fixed_point&lt;LhsRep, Exponent&gt; &amp; lhs, <span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> Exponent&gt;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rhs, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_arithmetic&lt;Rhs&gt;::value, <span class="dt">int</span>&gt;::type Dummy&gt;
    fixed_point&lt;LhsRep, Exponent&gt; &amp;
    fixed_point&lt;LhsRep, Exponent&gt;::<span class="kw">operator</span>*=(<span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> LhsRep, <span class="dt">int</span> Exponent&gt;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rhs, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_arithmetic&lt;Rhs&gt;::value, <span class="dt">int</span>&gt;::type Dummy&gt;
    fixed_point&lt;LhsRep, Exponent&gt; &amp;
    fixed_point&lt;LhsRep, Exponent&gt;::<span class="kw">operator</span>/=(<span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
    <span class="kw">constexpr</span> fixed_point&lt;Rep, Exponent&gt;
      sqrt(<span class="at">const</span> fixed_point&lt;Rep, Exponent&gt; &amp; x) <span class="kw">noexcept</span>;
}</code></pre></div>
<h4 id="fixed_point-class-template"><code>fixed_point&lt;&gt;</code> Class Template</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> Rep = <span class="dt">int</span>, <span class="dt">int</span> Exponent = <span class="dv">0</span>&gt;
<span class="kw">class</span> fixed_point
{
<span class="kw">public</span>:
  <span class="kw">using</span> rep = Rep;

  <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">int</span> exponent;
  <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">int</span> digits;
  <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">int</span> integer_digits;
  <span class="kw">constexpr</span> <span class="at">static</span> <span class="dt">int</span> fractional_digits;

  fixed_point() <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;_impl::is_integral&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> fixed_point(S s) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_floating_point&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> fixed_point(S s) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> FromRep, <span class="dt">int</span> FromExponent&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> fixed_point(<span class="at">const</span> fixed_point&lt;FromRep, FromExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;_impl::is_integral&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    fixed_point &amp; <span class="kw">operator</span>=(S s) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_floating_point&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    fixed_point &amp; <span class="kw">operator</span>=(S s) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> FromRep, <span class="dt">int</span> FromExponent&gt;
    fixed_point &amp; <span class="kw">operator</span>=(<span class="at">const</span> fixed_point&lt;FromRep, FromExponent&gt; &amp; rhs) <span class="kw">noexcept</span>;

  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;_impl::is_integral&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> <span class="kw">operator</span> S() <span class="at">const</span> <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_floating_point&lt;S&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    <span class="kw">explicit</span> <span class="kw">constexpr</span> <span class="kw">operator</span> S() <span class="at">const</span> <span class="kw">noexcept</span>;
  <span class="kw">explicit</span> <span class="kw">constexpr</span> <span class="kw">operator</span> <span class="dt">bool</span>() <span class="at">const</span> <span class="kw">noexcept</span>;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Rhs, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_arithmetic&lt;Rhs&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    fixed_point &amp;<span class="kw">operator</span>*=(<span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;
  <span class="kw">template</span> &lt;<span class="kw">class</span> Rhs, <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;<span class="bu">std::</span>is_arithmetic&lt;Rhs&gt;::value, <span class="dt">int</span>&gt;::type Dummy = <span class="dv">0</span>&gt;
    fixed_point &amp; <span class="kw">operator</span>/=(<span class="at">const</span> Rhs &amp; rhs) <span class="kw">noexcept</span>;

  <span class="kw">constexpr</span> rep data() <span class="at">const</span> <span class="kw">noexcept</span>;
  <span class="at">static</span> <span class="kw">constexpr</span> fixed_point from_data(rep r) <span class="kw">noexcept</span>;
};</code></pre></div>
<h2 id="vi.-future-issues">VI. Future Issues</h2>
<h3 id="library-support">Library Support</h3>
<p>Because the aim is to provide an alternative to existing arithmetic types which are supported by the standard library, it is conceivable that a future proposal might specialize existing class templates and overload existing functions.</p>
<p>Possible candidates for overloading include the functions defined in &lt;cmath&gt; and a templated specialization of <code>numeric_limits</code>. A new type trait, <code>is_fixed_point</code>, would also be useful.</p>
<p>While <code>fixed_point</code> is intended to provide drop-in replacements to existing built-ins, it may be preferable to deviate slightly from the behavior of certain standard functions. For example, overloads of functions from &lt;cmath&gt; will be considerably less concise, efficient and versatile if they obey rules surrounding error cases. In particular, the guarantee of setting <code>errno</code> in the case of an error prevents a function from being defined as pure. This highlights a wider issue surrounding the adoption of the functional approach and compile-time computation that is beyond the scope of this document.</p>
<p>One suggested addition is a specialization of <code>std::complex</code>. This would take the form:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> Rep, <span class="dt">int</span> Exponent&gt;
<span class="kw">class</span> complex&lt;fixed_point&lt;Rep, Exponent&gt;&gt;;</code></pre></div>
<p>This type's arithmetic operators would differ from existing specializations because <code>fixed_point&lt;&gt;</code> operators often return results of a different type to their operands. Hence signatures such as</p>
<pre class="c+"><code>template&lt;class T&gt;
complex&lt;T&gt; operator*( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);</code></pre>
<p>would need to be replaced with:</p>
<pre class="c+"><code>template&lt;class T&gt;
auto operator*( const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);</code></pre>
<h3 id="compile-time-bit-shift-operations">Compile-Time Bit-Shift Operations</h3>
<p>A notable feature of the <em>fp</em> library <a href="https://github.com/mizvekov/fp">[4]</a> is the creation of an alias for <code>integral_constant</code> which can be applied to the right-hand side of bit-shift operations. The type returned from this operation has identical bit-wise value to the left-hand input but with <code>Exponent</code> value adjusted by the amount of the right-hand side. It is essentially the same as the <code>trunc_shift_</code> functions and means that when shifting by literal values what looks looks like run-time operation is a compile-time calculation which guarantees no overflow or underflow.</p>
<h3 id="alternative-return-type-policies">Alternative Return Type Policies</h3>
<p>When devising a strategy for mitigating the risk of overflow during arithmetic operations, the number of integer and fractional bits stored in the result is an important choice. The <code>fixed_point</code> type picks one of the simpler options by default, but it is by no means the only viable one.</p>
<p>The <em>fp</em> library <a href="https://github.com/mizvekov/fp">[4]</a> returns a type whose size matches the inputs but whose exponent is shifted to preserve high bits. The arithmetic types proposed in P0106 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html">[8]</a> increase capacity to ensure that precision is preserved. Even greater control of the required capacity of a fixed-point type can be afforded by systems such as the <em>bounded::integer</em> library <a href="http://doublewise.net/c++/bounded/">[3]</a>.</p>
<p>A common requirement among these approaches is the ability to specify the return type of arithmetic operations. For this reason, named-function arithmetic operators which are more expressive than those proposed so far may be necessary.</p>
<p>These functions would specify a return type as a template parameter. For example:</p>
<pre><code>template &lt;class Result, class Lhs, class Rhs&gt;
constexpr Result fixed_point_multiply(const Lhs &amp; lhs, const Rhs &amp; rhs);</code></pre>
<h3 id="non-binary-radixes">Non-Binary Radixes</h3>
<p>Interest in decimal fixed-point arithmetic has been observed. It seems plausible that a general-purpose type could support both binary and decimal fixed-point types as follows:</p>
<pre class="c++14"><code>template&lt;class Rep, int Exponent, int Radix&gt;
class basic_fixed_point;

template&lt;class Rep, int Exponent&gt;
using fixed_point = basic_fixed_point&lt;Rep, Exponent, 2&gt;;

template&lt;class Rep, int Exponent&gt;
using decimal_fixed_point = basic_fixed_point&lt;Rep, Exponent, 10&gt;;</code></pre>
<p>This naming scheme imitates <code>basic_string</code> in order to illustrate a similar pattern.</p>
<p>Further investigation needs to be conducted in order to ascertain whether this break-down can maintain the same level of efficiency.</p>
<h2 id="vii.-prior-art">VII. Prior Art</h2>
<p>Many examples of fixed-point support in C and C++ exist. While almost all of them aim for low run-time cost and expressive alternatives to raw integer manipulation, they vary greatly in detail and in terms of their interface.</p>
<p>One especially interesting dichotomy is between solutions which offer a discrete selection of fixed-point types and libraries which contain a continuous range of exponents through type parameterization.</p>
<h3 id="n1169">N1169</h3>
<p>One example of the former is found in proposal N1169 <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1169.pdf">[5]</a>, the intent of which is to expose features found in certain embedded hardware. It introduces a succinct set of language-level fixed-point types and impose constraints on the number of integer or fractional digits each can possess.</p>
<p>As with all examples of discrete-type fixed-point support, the limited choice of exponents is a considerable restriction on the versatility and expressiveness of the API.</p>
<p>Nevertheless, it may be possible to harness performance gains provided by N1169 fixed-point types through explicit template specialization. This is likely to be a valuable proposition to potential users of the library who find themselves targeting platforms which support fixed-point arithmetic at the hardware level.</p>
<h3 id="p0106">P0106</h3>
<p>There are many other C++ libraries available which fall into the latter category of continuous-range fixed-point arithmetic <a href="https://github.com/mizvekov/fp">[4]</a> <a href="http://www.codeproject.com/Articles/37636/Fixed-Point-Class">[6]</a> <a href="https://github.com/viboes/fixed_point">[7]</a>. In particular, an existing library proposal by Lawrence Crowl, P0106 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html">[8]</a> (formerly N3352), aims to achieve very similar goals through similar means and warrants closer comparison than N1169.</p>
<p>P0106 introduces four class templates covering the quadrant of signed versus unsigned and fractional versus integer numeric types. It is intended to replace built-in types in a wide variety of situations and accordingly, is highly compile-time configurable in terms of how rounding and overflow are handled. Parameters to these four class templates include the storage in bits and - for fractional types - the resolution.</p>
<p>The <code>fixed_point</code> class template could probably - with a few caveats - be generated using the two fractional types, <code>nonnegative</code> and <code>negatable</code>, replacing the <code>Rep</code> parameter with the integer bit count of <code>Rep</code>, specifying <code>fastest</code> for the rounding mode and specifying <code>undefined</code> as the overflow mode.</p>
<p>However, <code>fixed_point</code> more closely and concisely caters to the needs of users who already use integer types and simply desire a more concise, less error-prone form. It more closely follows the four design aims of the library and - it can be argued - more closely follows the spirit of the standard in its pursuit of zero-cost abstraction.</p>
<p>Some aspects of the design of the P0106 API which back up these conclusion are that:</p>
<ul>
<li>the result of arithmetic operations closely resemble the <code>trunc_</code> function templates and are potentially more costly at run-time;</li>
<li>the nature of the range-specifying template parameters - through careful framing in mathematical terms - abstracts away valuable information regarding machine-critical type size information;</li>
<li>the breaking up of duties amongst four separate class templates introduces four new concepts and incurs additional mental load for relatively little gain while further detaching the interface from vital machine-level details and</li>
<li>the absence of the most negative number from signed types reduces the capacity of all types by one.</li>
</ul>
<p>The added versatility that the P0106 API provides regarding rounding and overflow handling are of relatively low priority to users who already bear the scars of battles with raw integer types. Nevertheless, providing them as options to be turned on or off at compile time is an ideal way to leave the choice in the hands of the user.</p>
<p>Many high-performance applications - in which fixed-point is of potential value - favor run-time checks during development which are subsequently deactivated in production builds. The P0106 interface is highly conducive to this style of development. The design proposed in this paper aims to achieve similar results by composing fixed-point types from custom integral types.</p>
<h2 id="viii.-acknowledgements">VIII. Acknowledgements</h2>
<p>SG6: Lawrence Crowl SG14: Guy Davidson, Michael Wong<br />
Contributors: Ed Ainsley, Billy Baker, Lance Dyson, Marco Foco, Mathias Gaunard, Clment Grgoire, Nicolas Guillemot, Kurt Guntheroth, Matt Kinzelman, Jol Lamotte, Sean Middleditch, Paul Robinson, Patrice Roy, Peter Schregle, Ryhor Spivak</p>
<h2 id="ix.-revisions">IX. Revisions</h2>
<p>This paper revises <a href="http://johnmcfarlane.github.io/fixed_point/papers/p0037r2.html">P0037R2</a>:</p>
<ul>
<li><code>width</code>, <code>set_width</code> etc. are moved from &lt;type_traits&gt; to &lt;cstdint&gt;;</li>
<li>greater use of <code>numeric_limits</code> in place of definitions from &lt;type_traits&gt;;</li>
<li>mention that exponents are typicaly negative;</li>
<li>stricted rules regarding implicit conversion to and from integer types;</li>
<li>revised rules for mixed-mode operator overloads;</li>
<li>change in behavior of arithmetic operators and named arithmetic functions;</li>
<li>brief discussion of <code>std::complex</code> specialization;</li>
<li>clearer reference to P0106R0, author and previous paper number.</li>
</ul>
<h2 id="x.-references">X. References</h2>
<ol style="list-style-type: decimal">
<li>Why Integer Coordinates?, <a href="http://www.pathengine.com/Contents/Overview/FundamentalConcepts/WhyIntegerCoordinates/page.php" class="uri">http://www.pathengine.com/Contents/Overview/FundamentalConcepts/WhyIntegerCoordinates/page.php</a></li>
<li>Rounding and Overflow in C++, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0105r0.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0105r0.html</a></li>
<li>C++ bounded::integer library, <a href="http://doublewise.net/c++/bounded/" class="uri">http://doublewise.net/c++/bounded/</a></li>
<li>fp, C++14 Fixed Point Library, <a href="https://github.com/mizvekov/fp" class="uri">https://github.com/mizvekov/fp</a></li>
<li>N1169, Extensions to support embedded processors, <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1169.pdf" class="uri">http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1169.pdf</a></li>
<li>fpmath, Fixed Point Math Library, <a href="http://www.codeproject.com/Articles/37636/Fixed-Point-Class" class="uri">http://www.codeproject.com/Articles/37636/Fixed-Point-Class</a></li>
<li>Boost fixed_point (proposed), Fixed point integral and fractional types, <a href="https://github.com/viboes/fixed_point" class="uri">https://github.com/viboes/fixed_point</a></li>
<li>P0106, C++ Binary Fixed-Point Arithmetic, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html" class="uri">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html</a></li>
<li>fixed_point, Reference Implementation of P0037, <a href="https://github.com/johnmcfarlane/fixed_point" class="uri">https://github.com/johnmcfarlane/fixed_point</a></li>
<li>P0381, Numeric Width, <a href="http://johnmcfarlane.github.io/fixed_point/papers/p0381r1.html" class="uri">http://johnmcfarlane.github.io/fixed_point/papers/p0381r1.html</a></li>
</ol>
<h2 id="xi.-appendix-1-reference-implementation">XI. Appendix 1: Reference Implementation</h2>
<p>An in-development implementation of the fixed_point class template and its essential supporting functions and types is available <a href="https://github.com/johnmcfarlane/fixed_point">[9]</a>.</p>
<p>Items include:</p>
<ul>
<li>utility header containing definitions for:
<ul>
<li>math and trigonometric functions and</li>
<li>a partial <code>numeric_limits</code> specialization;</li>
</ul></li>
<li>a type, <code>integer</code>, intended to explore and illustrate the potential of custom <code>Rep</code>;</li>
<li>a type, <code>elastic</code>, intended to illustrate the use of <code>fixed_point</code> to design better-behaved numeric types such as those presented in P0106 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0106r0.html">[8]</a>;</li>
<li>compile-time tests of <code>constexpr</code> operations;</li>
<li>run-time tests of assignment and exception-throwing behavior and</li>
<li>benchmarking support (used to generate results in this paper).</li>
</ul>
<h2 id="xii.-appendix-2-performance">XII. Appendix 2: Performance</h2>
<p>Despite a focus on usable interface and direct translation from integer-based fixed-point operations, there is an overwhelming expectation that the source code result in minimal instructions and clock cycles. A few preliminary numbers are presented to give a very early idea of how the API might perform.</p>
<p>Some notes:</p>
<ul>
<li>A few test functions were run, ranging from single arithmetic operations to basic geometric functions, performed against integer, floating-point and fixed-point types for comparison.</li>
<li>Figures were taken from a single CPU, OS and compiler, namely:
<ul>
<li>Debian clang version 3.5.0-10 (tags/RELEASE_350/final) (based on LLVM 3.5.0)</li>
<li>Target: x86_64-pc-linux-gnu</li>
<li>Thread model: posix</li>
</ul></li>
<li>Fixed inputs were provided to each function, meaning that branch prediction rarely fails. Results may also not represent the full range of inputs.</li>
<li>Details of the test harness used can be found in the source project mentioned in Appendix 1;</li>
<li>Times are in nanoseconds;</li>
<li>Code has not yet been optimized for performance.</li>
</ul>
<h3 id="types">Types</h3>
<p>Where applicable various combinations of integer, floating-point and fixed-point types were tested with the following identifiers:</p>
<ul>
<li><code>uint8_t</code>, <code>int8_t</code>, <code>uint16_t</code>, <code>int16_t</code>, <code>uint32_t</code>, <code>int32_t</code>, <code>uint64_t</code> and <code>int64_t</code> built-in integer types;</li>
<li><code>float</code>, <code>double</code> and <code>long double</code> built-in floating-point types;</li>
<li>s3:4, u4:4, s7:8, u8:8, s15:16, u16:16, s31:32 and u32:32 format fixed-point types.</li>
</ul>
<h3 id="basic-arithmetic">Basic Arithmetic</h3>
<p>Plus, minus, multiplication and division were tested in isolation using a number of different numeric types with the following results:</p>
<p>name cpu_time<br />
add(float) 1.78011<br />
add(double) 1.73966<br />
add(long double) 3.46011<br />
add(u4_4) 1.87726<br />
add(s3_4) 1.85051<br />
add(u8_8) 1.85417<br />
add(s7_8) 1.82057<br />
add(u16_16) 1.94194<br />
add(s15_16) 1.93463<br />
add(u32_32) 1.94674<br />
add(s31_32) 1.94446<br />
add(int8_t) 2.14857<br />
add(uint8_t) 2.12571<br />
add(int16_t) 1.9936<br />
add(uint16_t) 1.88229<br />
add(int32_t) 1.82126<br />
add(uint32_t) 1.76<br />
add(int64_t) 1.76<br />
add(uint64_t) 1.83223<br />
sub(float) 1.96617<br />
sub(double) 1.98491<br />
sub(long double) 3.55474<br />
sub(u4_4) 1.77006<br />
sub(s3_4) 1.72983<br />
sub(u8_8) 1.72983<br />
sub(s7_8) 1.72983<br />
sub(u16_16) 1.73966<br />
sub(s15_16) 1.85051<br />
sub(u32_32) 1.88229<br />
sub(s31_32) 1.87063<br />
sub(int8_t) 1.76<br />
sub(uint8_t) 1.74994<br />
sub(int16_t) 1.82126<br />
sub(uint16_t) 1.83794<br />
sub(int32_t) 1.89074<br />
sub(uint32_t) 1.85417<br />
sub(int64_t) 1.83703<br />
sub(uint64_t) 2.04914<br />
mul(float) 1.9376<br />
mul(double) 1.93097<br />
mul(long double) 102.446<br />
mul(u4_4) 2.46583<br />
mul(s3_4) 2.09189<br />
mul(u8_8) 2.08<br />
mul(s7_8) 2.18697<br />
mul(u16_16) 2.12571<br />
mul(s15_16) 2.10789<br />
mul(u32_32) 2.10789<br />
mul(s31_32) 2.10789<br />
mul(int8_t) 1.76<br />
mul(uint8_t) 1.78011<br />
mul(int16_t) 1.8432<br />
mul(uint16_t) 1.76914<br />
mul(int32_t) 1.78011<br />
mul(uint32_t) 2.19086<br />
mul(int64_t) 1.7696<br />
mul(uint64_t) 1.79017<br />
div(float) 5.12<br />
div(double) 7.64343<br />
div(long double) 8.304<br />
div(u4_4) 3.82171<br />
div(s3_4) 3.82171<br />
div(u8_8) 3.84<br />
div(s7_8) 3.8<br />
div(u16_16) 9.152<br />
div(s15_16) 11.232<br />
div(u32_32) 30.8434<br />
div(s31_32) 34<br />
div(int8_t) 3.82171<br />
div(uint8_t) 3.82171<br />
div(int16_t) 3.8<br />
div(uint16_t) 3.82171<br />
div(int32_t) 3.82171<br />
div(uint32_t) 3.81806<br />
div(int64_t) 10.2286<br />
div(uint64_t) 8.304</p>
<p>Among the slowest types are <code>long double</code>. It is likely that they are emulated in software. The next slowest operations are fixed-point multiply and divide operations - especially with 64-bit types. This is because values need to be promoted temporarily to double-width types. This is a known fixed-point technique which inevitably experiences slowdown where a 128-bit type is required on a 64-bit system.</p>
<p>Here is a section of the disassembly of the s15:16 multiply call:</p>
<pre><code>30:   mov    %r14,%rax  
      mov    %r15,%rax  
      movslq -0x28(%rbp),%rax  
      movslq -0x30(%rbp),%rcx  
      imul   %rax,%rcx  
      shr    $0x10,%rcx  
      mov    %ecx,-0x38(%rbp)  
      mov    %r12,%rax  
4c:   movzbl (%rbx),%eax  
      cmp    $0x1,%eax  
     jne    68  
54:   mov    0x8(%rbx),%rax  
      lea    0x1(%rax),%rcx  
      mov    %rcx,0x8(%rbx)  
      cmp    0x38(%rbx),%rax  
     jb     30</code></pre>
<p>The two 32-bit numbers are multiplied together and the result shifted down - much as it would if raw <code>int</code> values were used. The efficiency of this operation varies with the exponent. An exponent of zero should mean no shift at all.</p>
<h3 id="dimensional-magnitude-squared">3-Dimensional Magnitude Squared</h3>
<p>A fast <code>sqrt</code> implementation has not yet been tested with <code>fixed_point</code>. (The naive implementation takes over 300ns.) For this reason, a magnitude-squared function is measured, combining multiply and add operations:</p>
<pre><code>template &lt;class FP&gt;
constexpr FP magnitude_squared(const FP &amp; x, const FP &amp; y, const FP &amp; z)
{
    return x * x + y * y + z * z;
}</code></pre>
<p>Only real number formats are tested:</p>
<p>float 2.42606<br />
double 2.08<br />
long double 4.5056<br />
s3_4 2.768<br />
s7_8 2.77577<br />
s15_16 2.752<br />
s31_32 4.10331</p>
<p>Again, the size of the type seems to have the largest impact.</p>
<h3 id="circle-intersection">Circle Intersection</h3>
<p>A similar operation includes a comparison and branch:</p>
<pre><code>template &lt;class Real&gt;
bool circle_intersect_generic(Real x1, Real y1, Real r1, Real x2, Real y2, Real r2)
{
    auto x_diff = x2 - x1;
    auto y_diff = y2 - y1;
    auto distance_squared = x_diff * x_diff + y_diff * y_diff;

    auto touch_distance = r1 + r2;
    auto touch_distance_squared = touch_distance * touch_distance;

    return distance_squared &lt;= touch_distance_squared;
}</code></pre>
<p>float 3.46011<br />
double 3.48<br />
long double 6.4<br />
s3_4 3.88<br />
s7_8 4.5312<br />
s15_16 3.82171<br />
s31_32 5.92</p>
<p>Again, fixed-point and native performance are comparable.</p>
